	protected void removeRepository(final ExecutionEvent event,
			final boolean delete) {
		IWorkbenchSite activeSite = HandlerUtil.getActiveSite(event);
		IWorkbenchSiteProgressService service = (IWorkbenchSiteProgressService) activeSite
				.getService(IWorkbenchSiteProgressService.class);

		final List<RepositoryNode> selectedNodes;
		try {
			selectedNodes = getSelectedNodes(event);
		} catch (ExecutionException e) {
			Activator.handleError(e.getMessage(), e, true);
			return;
		}
		boolean deleteWorkingDir = false;
		if (delete) {
			if (selectedNodes.size() > 1) {
				return;
			} else if (selectedNodes.size() == 1) {
				Repository repository = selectedNodes.get(0).getObject();
				if (repository.isBare()) {
					String title = UIText.RemoveCommand_ConfirmDeleteBareRepositoryTitle;
					String message = NLS
							.bind(
									UIText.RemoveCommand_ConfirmDeleteBareRepositoryMessage,
									repository.getDirectory().getPath());
					if (!MessageDialog.openConfirm(getShell(event), title,
							message))
						return;
				} else {
					DeleteRepositoryConfirmDialog dlg = new DeleteRepositoryConfirmDialog(
							getShell(event), repository);
					if (dlg.open() != Window.OK)
						return;
					deleteWorkingDir = dlg.shouldDeleteWorkingDir();
				}
			}
		}

		final boolean deleteWorkDir = deleteWorkingDir;

		Job job = new Job("Remove Repositories Job") { 
			@Override
			protected IStatus run(IProgressMonitor monitor) {
				final List<IProject> projectsToDelete = new ArrayList<IProject>();

				monitor
						.setTaskName(UIText.RepositoriesView_DeleteRepoDeterminProjectsMessage);

				for (RepositoryNode node : selectedNodes) {
					if (node.getRepository().isBare())
						continue;
					File workDir = node.getRepository().getWorkTree();
					final IPath wdPath = new Path(workDir.getAbsolutePath());
					for (IProject prj : ResourcesPlugin.getWorkspace()
							.getRoot().getProjects()) {
						if (monitor.isCanceled())
							return Status.OK_STATUS;
						if (wdPath.isPrefixOf(prj.getLocation())) {
							projectsToDelete.add(prj);
						}
					}
				}

				final boolean[] confirmedCanceled = new boolean[] { false,
						false };

				if (!projectsToDelete.isEmpty()) {
					Display.getDefault().syncExec(new Runnable() {

						public void run() {
							try {
								confirmedCanceled[0] = confirmProjectDeletion(
										projectsToDelete, event);
							} catch (OperationCanceledException e) {
								confirmedCanceled[1] = true;
							}
						}
					});
				}
				if (confirmedCanceled[1]) {
					return Status.OK_STATUS;
				}
				if (confirmedCanceled[0]) {
					IWorkspaceRunnable wsr = new IWorkspaceRunnable() {

						public void run(IProgressMonitor actMonitor)
								throws CoreException {

							for (IProject prj : projectsToDelete)
								prj.delete(false, false, actMonitor);
						}
					};

					try {
						ResourcesPlugin.getWorkspace().run(wsr,
								ResourcesPlugin.getWorkspace().getRoot(),
								IWorkspace.AVOID_UPDATE, monitor);
					} catch (CoreException e1) {
						Activator.logError(e1.getMessage(), e1);
					}
				}
				for (RepositoryNode node : selectedNodes) {
					util.removeDir(node.getRepository().getDirectory());
				}

				if (delete) {
					try {
						for (RepositoryNode node : selectedNodes) {
							Repository repo = node.getRepository();
							if (!repo.isBare() && deleteWorkDir)
								FileUtils.delete(repo.getWorkTree(),
										FileUtils.RECURSIVE | FileUtils.RETRY);
							FileUtils.delete(repo.getDirectory(),
									FileUtils.RECURSIVE | FileUtils.RETRY
											| FileUtils.SKIP_MISSING);
						}
					} catch (IOException e) {
						return Activator.createErrorStatus(e.getMessage(), e);
					}
				}
				return Status.OK_STATUS;
			}
		};

		service.schedule(job);
	}

